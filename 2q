#include <stdint.h>
#include <stddef.h>
#include "drivers/ramdisk.h"
#include "drivers/ide_ata_driver.h"
#include "fs/superblock.h"
#include "fs/bitmap.h"
#include "fs/inode.h"
#include "fs/file.h"
#include "fs/directory.h"
#include "gdt/gdt.h"
#include "idt/idt.h"
#include "include/device_manager.h"
#include "include/block_device.h"
#include "include/strlength.h"
#include "include/memcopy.h"
#include "mem_alloc/heap.h"
#include "mem_alloc/multiboot.h"
#include "mem_alloc/mem_alloc.h"
#include "mem_alloc/mm.h"
#include "paging/paging.h"
#include "debug/debug.h"
#include "kernel_shell/shell.h"

#define FILE_TYPE 0
#define DIR_TYPE 1
	

static uint32_t debug = 0;
static void test_file_ops(uint32_t disk_size, struct block_device *disk);
static void inode_dump(struct Inode *inode);
static void debug_dump_bitmaps(struct Bitmap *inode_bitmap, struct Bitmap *block_bitmap);

void kernel_main(uint32_t magic, uint32_t multiboot_addr){
//	if (magic != 0x2BADB002){
//		panic("Not booted by GRUB");
//	}


	gdt_init();
	idt_init();


	multiboot_info_t *mbi = (multiboot_info_t *)multiboot_addr;
	mem_alloc_init(mbi);

	page_dir_init();
	heap_init();
	device_manager_init();

	struct block_device *dev = ide_init();
	int check = register_block_device(dev);

//	struct block_device *dev1 = ramdisk_init();
//        int check2 = register_block_device(dev1);

	test_file_ops(dev->block_size * dev->block_count, dev);

	if (debug){
		uint8_t *buffer = kmalloc(512);
		print_string(dev->name);
		print_string("\n\0");
		for (int i = 0; i < dev->block_size; i++) buffer[i]=1;
	
		int status = dev->ops->write_block(dev, 2 , buffer);
		status = dev->ops->write_block(dev, 3 , buffer);
		status = dev->ops->write_block(dev, 4 , buffer);
		status = dev->ops->write_block(dev, 500 , buffer);

		if (status != 0){
			print_string("FAILED WRITE\n\0");
		}else{
			print_string("SUCCESSFUL WRITE\n\0");
		}
		uint8_t *buffer2 = kmalloc(512);


		int status2 = dev->ops->read_block(dev, 500, buffer2);
		if (status2 != 0){
			print_string("FAILED WRITE\n\0");
		}else{
			print_string("SUCCESSFUL READ\n\0");
		}
	
		for (int i = 0; i < dev->block_size; i++){
			if(buffer2[i] == 1){
				//expected value of 1 == success
				print_string("1 \0");
				//break;
			}else{
				print_string("UNVERIFIED DATA\n\0");
				break;
			}
		}
		

		int status3 = dev->ops->flush(dev);
		print_string("\n\0");


		if(status3 == -1){
			print_string("****FLUSH DEVICE FAIL****\n\0");
		}else{
			print_string("****FLUSH DEVICE SUCCESS****");
		}

		kfree(buffer);
		kfree(buffer2);
	}

	shell_run();

	while(1){
		
	};

}

static void test_file_ops(uint32_t disk_size, struct block_device *disk){
	struct Superblock *sb = kmalloc(sizeof(struct Superblock));
	struct Bitmap *inode_bitmap = kmalloc(sizeof(struct Bitmap));
	struct Bitmap *block_bitmap = kmalloc(sizeof(struct Bitmap));
	int test_file_creation = 0;

	superblock_init(sb, disk_size);
	fs_bitmap_init(inode_bitmap, 256);
	fs_bitmap_init(block_bitmap, sb->total_blocks);
	//create directory testing
	uint32_t root_inode_num;// = 1;//root exists at inode 1
	file_create(sb, &root_inode_num, inode_bitmap, 0777, disk);
	struct Inode *root_inode = kmalloc(sizeof(struct Inode));
	inode_read(root_inode, root_inode_num, sb, disk);


	root_inode->type = DIR_TYPE;
	inode_write(root_inode, root_inode_num, sb, disk);


	dir_add_entry(root_inode, root_inode_num, ".", root_inode_num, DIR_TYPE, disk, sb, block_bitmap);
	inode_read(root_inode, root_inode_num, sb, disk);
	dir_add_entry(root_inode, root_inode_num, "..", root_inode_num, DIR_TYPE, disk, sb, block_bitmap);

	dir_create(root_inode_num, "mydir", 0777, inode_bitmap, block_bitmap, sb, disk);
	
	uint32_t mydir_inode_num;
	print_int(dir_lookup(root_inode_num, "mydir", &mydir_inode_num, sb, disk));
//	file_create_inside_dir(root_inode_num, "test.txt", 0644, inode_bitmap, block_bitmap, sb, disk);


	//file_write(struct Inode *inode, uint32_t inode_num, void *buffer, uint32_t offset, uint32_t size, struct Bitmap *block_bitmap, sb, disk)	



}
static void inode_dump(struct Inode *inode) {
    print_string("==== INODE DUMP ====\n");

    print_string("size: ");
    print_int(inode->size);
    print_string(" bytes\n");

    print_string("type: ");
    print_int(inode->type);
    print_string("\n");

    print_string("permissions: ");
    print_int(inode->permissions);
    print_string("\n");

    print_string("created_time: ");
    print_int((uint32_t)inode->created_time);
    print_string("\n");

    print_string("modified_time: ");
    print_int((uint32_t)inode->modified_time);
    print_string("\n");

    print_string("data blocks:\n");
    for (int i = 0; i < 12; i++) {
        print_string("  [");
        print_int(i);
        print_string("] = ");
        print_int(inode->data_blocks[i]);
        print_string("\n");
    }

    print_string("====================\n");
}


static void debug_dump_bitmaps(struct Bitmap *inode_bitmap, struct Bitmap *block_bitmap) {
    print_string("=== INODE BITMAP ===\n\0");
    print_string("Total inodes: \0");
    print_int(inode_bitmap->size);
    print_string("\n\0");

    print_string("Allocated inodes: \0");
    for (uint32_t i = 0; i < inode_bitmap->size && i < 32; i++) {  // Show first 32
        if (fs_bitmap_test(inode_bitmap, i)) {
            print_int(i);
            print_string(" \0");
        }
    }
    print_string("\n\0");

    print_string("First 32 bits: \0");
    for (uint32_t i = 0; i < 32 && i < inode_bitmap->size; i++) {
        print_int(fs_bitmap_test(inode_bitmap, i) ? 1 : 0);
    }
    print_string("\n\n\0");

    print_string("=== BLOCK BITMAP ===\n\0");
    print_string("Total blocks: \0");
    print_int(block_bitmap->size);
    print_string("\n\0");

    print_string("Allocated blocks: \0");
    for (uint32_t i = 0; i < block_bitmap->size && i < 32; i++) {  // Show first 32
        if (fs_bitmap_test(block_bitmap, i)) {
            print_int(i);
            print_string(" \0");
        }
    }
    print_string("\n\0");

    print_string("First 32 bits: \0");
    for (uint32_t i = 0; i < 32 && i < block_bitmap->size; i++) {
        print_int(fs_bitmap_test(block_bitmap, i) ? 1 : 0);
    }
    print_string("\n\n\0");
}
